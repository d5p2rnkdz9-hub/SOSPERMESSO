---
phase: 41-prassi-locali-mvp
plan: 03
type: execute
wave: 2
depends_on: ["41-01", "41-02"]
files_modified:
  - src/scripts/prassi.js
  - src/pages/documents-primo.liquid
  - src/pages/documents-rinnovo.liquid
  - netlify/functions/notion-webhook.js
autonomous: true
user_setup:
  - service: netlify
    why: "Build Hook URL for auto-deploy when Notion content changes"
    env_vars:
      - name: NETLIFY_BUILD_HOOK_URL
        source: "Netlify Dashboard > Site settings > Build & deploy > Build hooks > Add build hook (name: 'notion-prassi-update'). Copy the generated URL."
    dashboard_config:
      - task: "Create Netlify Build Hook"
        location: "Netlify Dashboard > Site settings > Build & deploy > Build hooks"
  - service: notion
    why: "Webhook for auto-deploy when moderation status changes"
    env_vars:
      - name: NOTION_WEBHOOK_SECRET
        source: "Create a Notion webhook: Notion Settings > Connections > Webhooks > Create webhook. Set URL to https://[your-site].netlify.app/.netlify/functions/notion-webhook. Subscribe to 'page.content_updated' events. Copy the signing secret."
    dashboard_config:
      - task: "Create Notion Webhook"
        location: "Notion Settings > Connections > Webhooks"

must_haves:
  truths:
    - "Users can open a submission modal form from the 'Aggiungi la tua esperienza' button"
    - "City field has autocomplete from 105 questura cities"
    - "After submit, user sees thank-you message with submitted practice preview"
    - "Each practice card has Confermo/Non confermo vote buttons"
    - "Voting updates counts in real-time on the page"
    - "Duplicate votes on same item show 'already voted' message"
    - "Notion webhook triggers Netlify rebuild when content changes"
  artifacts:
    - path: "src/scripts/prassi.js"
      provides: "Client-side JS for modal form, city autocomplete, voting, and fetch calls"
      min_lines: 100
    - path: "netlify/functions/notion-webhook.js"
      provides: "Webhook endpoint that triggers Netlify build"
      min_lines: 25
  key_links:
    - from: "src/scripts/prassi.js"
      to: "/.netlify/functions/submit-prassi"
      via: "fetch POST on form submit"
      pattern: "fetch.*submit-prassi"
    - from: "src/scripts/prassi.js"
      to: "/.netlify/functions/vote-prassi"
      via: "fetch POST on vote click"
      pattern: "fetch.*vote-prassi"
    - from: "netlify/functions/notion-webhook.js"
      to: "Netlify Build Hook"
      via: "fetch POST to NETLIFY_BUILD_HOOK_URL"
      pattern: "NETLIFY_BUILD_HOOK_URL"
---

<objective>
Wire up the dynamic interactions: submission modal form with city autocomplete, client-side voting UI, and Notion webhook for auto-deploy. This connects the static display (Plan 01) to the serverless endpoints (Plan 02).

Purpose: Without this plan, users can see existing practices but can't contribute new ones or vote. This adds the interactive layer that makes prassi locali a living, community-driven feature.

Output: `src/scripts/prassi.js` (client-side logic), updated document templates (modal + vote buttons), `netlify/functions/notion-webhook.js` (auto-deploy).
</objective>

<execution_context>
@/Users/albertopasquero/.claude/get-shit-done/workflows/execute-plan.md
@/Users/albertopasquero/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/41-prassi-locali-mvp/41-CONTEXT.md
@.planning/phases/41-prassi-locali-mvp/41-RESEARCH.md
@.planning/phases/41-prassi-locali-mvp/41-01-SUMMARY.md
@.planning/phases/41-prassi-locali-mvp/41-02-SUMMARY.md
@src/components/contact-form.html
@src/scripts/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prassi.js client-side script and update document templates</name>
  <files>src/scripts/prassi.js, src/pages/documents-primo.liquid, src/pages/documents-rinnovo.liquid</files>
  <action>
**Step 1: Create `src/scripts/prassi.js`**

This script handles three features: (A) submission modal form, (B) voting UI, and (C) city autocomplete. Structure it as an IIFE to avoid global scope pollution, except for `openPrassiModal()` which must be globally accessible (called from onclick in templates).

**A. Submission Modal**

Create a modal following the exact same pattern as `src/components/contact-form.html`:
- Modal HTML is injected via JavaScript (not a separate include) to keep it self-contained
- `window.openPrassiModal = function(pageUrl, pageSlug)` — opens modal, pre-fills hidden pageUrl and pageSlug fields
- Modal structure:
  ```
  .prassi-modal (fixed overlay, z-index 9999)
    .prassi-modal-backdrop (click to close)
    .prassi-modal-content (white card, max-width 600px)
      .prassi-modal-close button
      header: icon, title "Condividi la tua esperienza", subtitle
      form#prassi-form:
        - City input with <datalist> (105 cities) — required
        - Description textarea (min 20 chars) — required
        - Date input (type="date") — optional
        - Category input (free text) — optional
        - Hidden: pageUrl, pageSlug
        - Submit button with loading state
      .prassi-form-response (success/error messages)
  ```
- On submit:
  - Validate city is in the 105-city list (setCustomValidity if not)
  - Validate description >= 20 characters
  - Show loading state (disable button, show spinner)
  - POST to `/.netlify/functions/submit-prassi` with JSON body
  - On success: show thank-you message + preview of submitted practice with "In attesa di approvazione" badge (gray/muted styling). Keep modal open for 3 seconds showing the preview, then close.
  - On error: show error message, re-enable button
  - Reset form after successful submission
- Close modal: click backdrop, click X, press Escape

The modal CSS should be injected alongside the HTML (same pattern as contact-form.html with `<style>` in the injected content). Reuse the existing `.contact-modal*` CSS class patterns but with `.prassi-modal*` prefix. Key styles:
- Same backdrop blur and fadeIn animation
- Same slideUp animation for content
- Same form input styles (`.form-group`, `.form-label`, `.form-input`, etc.)
- ".prassi-pending-preview" — muted card with dashed border and "In attesa di approvazione" badge

**B. Voting UI**

Add vote buttons to each `.prassi-card` on the page:
- On DOMContentLoaded, find all `.prassi-card` elements
- For each card, enhance the `.prassi-card-votes` div with interactive buttons:
  ```html
  <button class="vote-btn vote-confermo-btn" data-vote="confermo">
    <span class="vote-icon">&#10003;</span> Confermo <span class="vote-count">N</span>
  </button>
  <button class="vote-btn vote-non-confermo-btn" data-vote="non_confermo">
    <span class="vote-icon">&#10007;</span> Non confermo <span class="vote-count">N</span>
  </button>
  ```
- Read initial counts from the static HTML text content (parse "Confermo: N" and "Non confermo: N")
- On click:
  - Check localStorage for `voted:${prassiId}` — if exists and less than 24h old, show "Hai gia votato" message, don't send request
  - Disable both buttons temporarily
  - POST to `/.netlify/functions/vote-prassi` with `{ id: prassiId, voteType }`
  - On success: update displayed count, store `voted:${prassiId}` with timestamp in localStorage, visually mark the chosen button as "active" (highlight color)
  - On 429 (rate limited): show message below buttons ("Troppi voti, riprova tra poco")
  - On error: show generic error, re-enable buttons
- Style vote buttons:
  - Default: outlined style, muted colors
  - Hover: slight background fill
  - Active/voted: filled background (teal for confermo, soft red for non confermo)
  - Disabled: opacity 0.6

**C. City Autocomplete**

The city `<datalist>` with 105 options provides native browser autocomplete. Add JS validation:
- On blur of city input, validate against the cities array
- If not in list, `setCustomValidity('Seleziona una citta dalla lista')`
- If valid, `setCustomValidity('')`
- Store the QUESTURA_CITIES array in the script (same 105 cities as in submit-prassi.js)

**Step 2: Update document templates to include prassi.js**

In both `src/pages/documents-primo.liquid` and `src/pages/documents-rinnovo.liquid`:
- Add `<script src="../scripts/prassi.js"></script>` before the closing `</body>` tag (after app.js)
- Update the "Aggiungi la tua esperienza" button's onclick to pass page context:
  ```
  onclick="openPrassiModal('https://sospermesso.it/src/pages/documenti-{{ doc.slug }}-primo.html', '{{ doc.slug }}')"
  ```
  (Use '-rinnovo.html' and same slug for the rinnovo template)

**Important patterns from existing codebase:**
- Match contact-form.html's modal pattern exactly (z-index 9999, backdrop blur, slideUp animation)
- Use 16px font-size on mobile inputs (prevents iOS zoom — existing pattern)
- Use existing CSS variable names (var(--taxi-yellow), var(--accent-teal), etc.)
- IIFE pattern for encapsulation (same as app.js and contact-form.html)
  </action>
  <verify>
- `ls src/scripts/prassi.js` — file exists
- `grep "openPrassiModal" src/scripts/prassi.js` — function defined
- `grep "vote-prassi" src/scripts/prassi.js` — fetch to vote endpoint
- `grep "submit-prassi" src/scripts/prassi.js` — fetch to submit endpoint
- `grep "prassi.js" src/pages/documents-primo.liquid` — script included
- `grep "prassi.js" src/pages/documents-rinnovo.liquid` — script included
- `npm run build:11ty 2>&1 | tail -5` — build succeeds
  </verify>
  <done>Submission modal with city autocomplete, voting UI with localStorage + API integration, and script included in both document templates.</done>
</task>

<task type="auto">
  <name>Task 2: Create Notion webhook endpoint for auto-deploy</name>
  <files>netlify/functions/notion-webhook.js</files>
  <action>
Create `netlify/functions/notion-webhook.js` — Netlify Functions v2.0 (ESM).

The function must:
- Accept POST method only (return 405 for others)
- Verify Notion webhook signature:
  - Get signature from `req.headers.get('x-notion-signature')` header
  - Read raw body with `req.text()`
  - Compute expected: `'sha256=' + crypto.createHmac('sha256', process.env.NOTION_WEBHOOK_SECRET).update(body).digest('hex')`
  - Use `crypto.timingSafeEqual()` to compare (prevents timing attacks). Convert both strings to Buffers first.
  - If signature invalid, return 401 "Invalid signature"
- Handle Notion webhook verification challenge:
  - Notion sends a POST with `{ "type": "url_verification", "challenge": "..." }` on webhook setup
  - If `payload.type === 'url_verification'`, return 200 with `{ "challenge": payload.challenge }`
- For real events (`payload.type === 'event'`):
  - Check if event type is `page.content_updated` or `data_source.schema_updated`
  - If yes, trigger Netlify build by POSTing to `process.env.NETLIFY_BUILD_HOOK_URL`
  - Return 200 with `{ message: "Build triggered" }`
  - For other event types, return 200 with `{ message: "Event ignored" }`
- Log events for debugging: `console.log('[notion-webhook] Event:', payload.type, payload.event?.type)`
- Import crypto: `import crypto from 'crypto'`
- No CORS headers needed (this is server-to-server, not browser-to-server)
  </action>
  <verify>
- `ls netlify/functions/notion-webhook.js` — file exists
- `grep "timingSafeEqual" netlify/functions/notion-webhook.js` — secure comparison used
- `grep "NETLIFY_BUILD_HOOK_URL" netlify/functions/notion-webhook.js` — build hook integration
- `grep "url_verification" netlify/functions/notion-webhook.js` — verification challenge handled
  </verify>
  <done>Webhook endpoint verifies Notion signatures, handles verification challenge, and triggers Netlify build on content updates.</done>
</task>

</tasks>

<verification>
1. `src/scripts/prassi.js` exists with modal, voting, and autocomplete logic
2. Modal opens and closes correctly (backdrop click, X button, Escape key)
3. City autocomplete validates against 105 cities
4. Vote buttons enhance static vote counts display
5. Form submits to `/.netlify/functions/submit-prassi`
6. Votes post to `/.netlify/functions/vote-prassi`
7. `netlify/functions/notion-webhook.js` exists with signature verification
8. Document templates include prassi.js script
9. `npm run build:11ty` succeeds
</verification>

<success_criteria>
- Complete interactive layer: users can submit practices and vote
- Modal form matches existing contact form UX patterns
- Vote buttons show counts and handle localStorage duplicate prevention
- Webhook endpoint securely triggers rebuilds
- All client-side fetch calls include proper error handling
</success_criteria>

<output>
After completion, create `.planning/phases/41-prassi-locali-mvp/41-03-SUMMARY.md`
</output>
