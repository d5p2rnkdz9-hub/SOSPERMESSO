---
phase: 20-batch-translation-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - scripts/translate-batch.js
autonomous: true

must_haves:
  truths:
    - "Translated pages preserve all HTML formatting (headings, lists, links)"
    - "Links in translated pages navigate to other EN pages correctly"
    - "Translated pages display lang='en' in browser inspector"
    - "Text content is translated while HTML structure remains intact"
  artifacts:
    - path: "scripts/translate-batch.js"
      provides: "HTML extraction and reassembly functions"
      contains: "extractSegments"
    - path: "scripts/translate-batch.js"
      provides: "Link transformation function"
      contains: "transformLinks"
  key_links:
    - from: "scripts/translate-batch.js"
      to: "cheerio"
      via: "require/import"
      pattern: "cheerio"
    - from: "extractSegments"
      to: "reassembleHtml"
      via: "segment ID matching"
      pattern: "segment\\.id"
---

<objective>
Implement HTML segmentation and link transformation for structure-preserving translation.

Purpose: AI translation works best on clean text segments. This plan extracts translatable text, preserves HTML structure, and handles link path updates - the core transformation pipeline.

Output: Functions for extracting text segments, transforming links, and reassembling translated content back into valid HTML. Each function has a working test mode for verification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-batch-translation-pipeline/20-RESEARCH.md
@.planning/phases/20-batch-translation-pipeline/20-01-SUMMARY.md

# Reference for page structure
@en/src/pages/permesso-studio.html (POC translated page)
@src/pages/permesso-studio.html (IT source)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HTML segment extraction with cheerio + test mode</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add `extractSegments(html)` function using cheerio AND implement the `--test-extract` handler:

```javascript
const cheerio = require('cheerio');

/**
 * Extract translatable text segments from HTML
 * @param {string} html - Source HTML content
 * @returns {{ $: CheerioAPI, segments: Array, metadata: Object }}
 */
function extractSegments(html) {
  const $ = cheerio.load(html, { decodeEntities: false });
  const segments = [];
  let segmentId = 0;

  // Extract metadata first
  const metadata = {
    title: $('title').text(),
    description: $('meta[name="description"]').attr('content') || ''
  };

  // Mark metadata elements for later update
  $('title').attr('data-translate-id', 'title');
  $('meta[name="description"]').attr('data-translate-id', 'description');

  // Elements containing translatable text
  const textSelectors = [
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'p', 'li', 'td', 'th',
    'span:not(.no-translate)',
    'a:not([href^="http"]):not([href^="mailto"])',
    'button', 'label',
    '.alert', '.card-title', '.card-text',
    '.breadcrumb-item'
  ].join(', ');

  $(textSelectors).each((i, el) => {
    const $el = $(el);

    // Skip if inside script, style, or already processed parent
    if ($el.parents('script, style, noscript').length) return;
    if ($el.attr('data-translate-id')) return;

    // Skip empty or whitespace-only
    const text = $el.html();
    if (!text || !text.trim()) return;

    // Skip if translate="no" attribute
    if ($el.attr('translate') === 'no') return;

    // Skip children that will be processed separately
    if ($el.find(textSelectors).length > 0) {
      // Has child text elements - skip, they'll be processed
      return;
    }

    // Store segment with unique ID
    const id = segmentId++;
    $el.attr('data-translate-id', id.toString());

    segments.push({
      id,
      text: text.trim(),
      tagName: el.tagName.toLowerCase(),
      selector: generateSelector($el)
    });
  });

  return { $, segments, metadata };
}

/**
 * Generate a unique selector for an element
 */
function generateSelector($el) {
  const tag = $el[0].tagName.toLowerCase();
  const id = $el.attr('id');
  if (id) return `#${id}`;

  const classes = $el.attr('class');
  if (classes) {
    const firstClass = classes.split(' ')[0];
    return `${tag}.${firstClass}`;
  }

  return tag;
}
```

**ALSO implement the --test-extract handler** in the CLI section:

```javascript
// In CLI handling section (after arg parsing)
if (args.includes('--test-extract')) {
  const fileIndex = args.indexOf('--test-extract') + 1;
  const filePath = args[fileIndex];
  if (!filePath) {
    console.error('Error: --test-extract requires a file path');
    process.exit(1);
  }

  const html = await fs.readFile(filePath, 'utf-8');
  const { segments, metadata } = extractSegments(html);

  console.log(`\n=== SEGMENT EXTRACTION TEST ===`);
  console.log(`File: ${filePath}`);
  console.log(`Title: ${metadata.title}`);
  console.log(`Description: ${metadata.description.slice(0, 50)}...`);
  console.log(`\nExtracted ${segments.length} segments:\n`);

  segments.slice(0, 15).forEach(seg => {
    const preview = seg.text.slice(0, 60).replace(/\n/g, ' ');
    console.log(`  [${seg.id}] <${seg.tagName}> ${preview}${seg.text.length > 60 ? '...' : ''}`);
  });

  if (segments.length > 15) {
    console.log(`  ... and ${segments.length - 15} more segments`);
  }

  process.exit(0);
}
```

Key points:
- Use cheerio's `decodeEntities: false` to preserve HTML entities
- Mark elements with `data-translate-id` for later reassembly
- Skip nested text elements (process leaf nodes only)
- Preserve inner HTML (includes <strong>, <em>, <a> tags)
- Extract title and meta description separately
- Test mode shows extracted segments with previews
  </action>
  <verify>
```bash
node scripts/translate-batch.js --test-extract src/pages/permesso-studio.html 2>&1 | head -30
```
Should show "SEGMENT EXTRACTION TEST" header, title, and 15+ extracted segments with IDs
  </verify>
  <done>extractSegments function works, --test-extract shows 20+ segments extracted from a permit page with readable output</done>
</task>

<task type="auto">
  <name>Task 2: Implement link and path transformation + test mode</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add `transformLinks($)` function to update all internal links and asset paths, AND implement the `--test-links` handler:

```javascript
/**
 * Transform links and paths for EN version
 * EN pages are in /en/src/pages/ - one level deeper than IT
 * @param {CheerioAPI} $ - Cheerio instance
 */
function transformLinks($) {
  // Update lang attribute
  $('html').attr('lang', 'en');

  // Transform internal page links
  $('a[href]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');

    // Skip external links, anchors, mailto, tel
    if (!href) return;
    if (href.startsWith('http') || href.startsWith('#') ||
        href.startsWith('mailto:') || href.startsWith('tel:')) return;

    // Transform relative paths
    // IT: ../chi-siamo.html -> chi-siamo.html (same level in EN)
    // IT: chi-siamo.html -> chi-siamo.html (already relative)
    // Root: src/pages/x.html -> just use x.html for EN internal

    // For links within src/pages, keep filename only
    const filename = path.basename(href);
    if (href.includes('.html') && !href.includes('..')) {
      $el.attr('href', filename);
    }
  });

  // Transform asset paths (CSS, JS, images)
  // EN pages are in /en/src/pages/ - need to go up one more level
  // IT: ../styles/main.css
  // EN: ../../styles/main.css

  $('link[href^="../styles"]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');
    // ../styles -> ../../styles
    $el.attr('href', href.replace('../styles', '../../styles'));
  });

  $('script[src^="../scripts"]').each((i, el) => {
    const $el = $(el);
    const src = $el.attr('src');
    $el.attr('src', src.replace('../scripts', '../../scripts'));
  });

  // Images - adjust path depth
  $('img[src]').each((i, el) => {
    const $el = $(el);
    const src = $el.attr('src');
    if (src && src.startsWith('../')) {
      // Add one more level up
      $el.attr('src', '../' + src);
    }
  });

  // Logo specifically - from ../../../images to ../../../../images
  $('img[src*="images/logo"]').each((i, el) => {
    const $el = $(el);
    const src = $el.attr('src');
    if (src.includes('../../../images')) {
      $el.attr('src', src.replace('../../../images', '../../../../images'));
    }
  });

  // Favicon links
  $('link[href*="images/logo"]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');
    if (href.includes('../../../images')) {
      $el.attr('href', href.replace('../../../images', '../../../../images'));
    }
  });

  // Home link (logo)
  $('a[href="../../index.html"]').attr('href', '../../../en/index.html');
  $('a.logo[href]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');
    if (href && !href.includes('/en/')) {
      // Point to EN homepage
      $el.attr('href', '../../../en/index.html');
    }
  });
}
```

**ALSO implement the --test-links handler** in the CLI section:

```javascript
// In CLI handling section
if (args.includes('--test-links')) {
  const fileIndex = args.indexOf('--test-links') + 1;
  const filePath = args[fileIndex];
  if (!filePath) {
    console.error('Error: --test-links requires a file path');
    process.exit(1);
  }

  const html = await fs.readFile(filePath, 'utf-8');
  const $ = cheerio.load(html, { decodeEntities: false });

  // Show BEFORE state
  console.log(`\n=== LINK TRANSFORMATION TEST ===`);
  console.log(`File: ${filePath}`);
  console.log(`\n--- BEFORE ---`);
  console.log(`lang: ${$('html').attr('lang') || '(not set)'}`);

  const beforeLinks = [];
  $('link[href]').slice(0, 5).each((i, el) => beforeLinks.push($(el).attr('href')));
  $('a[href]').slice(0, 5).each((i, el) => beforeLinks.push($(el).attr('href')));
  console.log(`Sample links: ${beforeLinks.slice(0, 5).join(', ')}`);

  // Apply transformation
  transformLinks($);

  // Show AFTER state
  console.log(`\n--- AFTER ---`);
  console.log(`lang: ${$('html').attr('lang')}`);

  const afterLinks = [];
  $('link[href]').slice(0, 5).each((i, el) => afterLinks.push($(el).attr('href')));
  $('a[href]').slice(0, 5).each((i, el) => afterLinks.push($(el).attr('href')));
  console.log(`Sample links: ${afterLinks.slice(0, 5).join(', ')}`);

  // Show specific transformations
  console.log(`\n--- KEY TRANSFORMATIONS ---`);
  $('link[href*="styles"]').slice(0, 2).each((i, el) => {
    console.log(`  CSS: ${$(el).attr('href')}`);
  });
  $('a[href*=".html"]').slice(0, 3).each((i, el) => {
    console.log(`  Link: ${$(el).attr('href')}`);
  });

  process.exit(0);
}
```

Important path mappings:
- IT `src/pages/x.html` -> EN `en/src/pages/x.html`
- Styles: `../styles/` -> `../../styles/`
- Images: `../../../images/` -> `../../../../images/`
- Home: `../../index.html` -> `../../../en/index.html`
  </action>
  <verify>
```bash
node scripts/translate-batch.js --test-links src/pages/permesso-studio.html 2>&1
```
Should show "LINK TRANSFORMATION TEST" with BEFORE/AFTER comparison, lang="en" in AFTER section, and ../../styles paths
  </verify>
  <done>transformLinks function works, --test-links shows lang="en" and correct ../../ path adjustments in AFTER section</done>
</task>

<task type="auto">
  <name>Task 3: Implement HTML reassembly from translated segments + test mode</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add `reassembleHtml($, translatedSegments, translatedMeta)` function AND implement the `--test-reassemble` handler:

```javascript
/**
 * Reassemble HTML with translated content
 * @param {CheerioAPI} $ - Cheerio instance with data-translate-id markers
 * @param {Array} translatedSegments - [{ id, text }] from Claude
 * @param {{ title: string, description: string }} translatedMeta
 * @returns {string} Complete translated HTML
 */
function reassembleHtml($, translatedSegments, translatedMeta) {
  // Create lookup map for fast access
  const translations = new Map(
    translatedSegments.map(s => [s.id.toString(), s.text])
  );

  // Update title
  if (translatedMeta.title) {
    $('title').text(translatedMeta.title);
  }

  // Update meta description
  if (translatedMeta.description) {
    $('meta[name="description"]').attr('content', translatedMeta.description);
  }

  // Update all marked elements
  $('[data-translate-id]').each((i, el) => {
    const $el = $(el);
    const id = $el.attr('data-translate-id');

    // Skip title and description (handled above)
    if (id === 'title' || id === 'description') return;

    const translated = translations.get(id);
    if (translated) {
      // Use html() to preserve any inner HTML formatting
      $el.html(translated);
    }

    // Remove the marker attribute
    $el.removeAttr('data-translate-id');
  });

  // Clean up any remaining markers
  $('[data-translate-id]').removeAttr('data-translate-id');

  return $.html();
}

/**
 * Apply glossary post-processing to translated text
 * Ensures consistent terminology even if AI varied
 */
function applyGlossaryPostProcess(html) {
  const glossary = require('./translation-glossary.json');
  let result = html;

  // Apply UI strings exactly (case-sensitive)
  for (const [it, en] of Object.entries(glossary.uiStrings)) {
    // Only replace if Italian string is found (shouldn't be, but safety check)
    result = result.split(it).join(en);
  }

  // For terms, do case-insensitive check for Italian -> ensure English
  // This catches any terms the AI might have missed
  for (const [it, en] of Object.entries(glossary.terms)) {
    const regex = new RegExp(`\\b${escapeRegex(it)}\\b`, 'gi');
    // Replace Italian term with English equivalent
    result = result.replace(regex, en);
  }

  return result;
}

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```

**ALSO implement the --test-reassemble handler** in the CLI section:

```javascript
// In CLI handling section
if (args.includes('--test-reassemble')) {
  const fileIndex = args.indexOf('--test-reassemble') + 1;
  const filePath = args[fileIndex];
  if (!filePath) {
    console.error('Error: --test-reassemble requires a file path');
    process.exit(1);
  }

  const html = await fs.readFile(filePath, 'utf-8');

  // Step 1: Extract segments
  const { $, segments, metadata } = extractSegments(html);
  console.log(`\n=== REASSEMBLY TEST ===`);
  console.log(`File: ${filePath}`);
  console.log(`Extracted ${segments.length} segments`);

  // Step 2: Create mock translations (UPPERCASE each segment as test)
  const mockTranslations = segments.map(seg => ({
    id: seg.id,
    text: seg.text.toUpperCase()  // Mock translation = uppercase
  }));

  const mockMeta = {
    title: metadata.title.toUpperCase(),
    description: metadata.description.toUpperCase()
  };

  console.log(`\n--- MOCK TRANSLATIONS (uppercase as test) ---`);
  mockTranslations.slice(0, 5).forEach(t => {
    const preview = t.text.slice(0, 50);
    console.log(`  [${t.id}] ${preview}...`);
  });

  // Step 3: Reassemble
  const reassembled = reassembleHtml($, mockTranslations, mockMeta);

  // Step 4: Verify structure preserved
  const $result = cheerio.load(reassembled, { decodeEntities: false });

  console.log(`\n--- REASSEMBLY RESULT ---`);
  console.log(`Title: ${$result('title').text()}`);
  console.log(`H1 count: ${$result('h1').length}`);
  console.log(`H2 count: ${$result('h2').length}`);
  console.log(`Paragraph count: ${$result('p').length}`);
  console.log(`Link count: ${$result('a').length}`);

  // Show a sample of transformed content
  console.log(`\n--- SAMPLE OUTPUT ---`);
  const firstH1 = $result('h1').first().text();
  const firstP = $result('p').first().text();
  console.log(`First H1: ${firstH1.slice(0, 60)}...`);
  console.log(`First P: ${firstP.slice(0, 60)}...`);

  // Check for data-translate-id cleanup
  const remainingMarkers = $result('[data-translate-id]').length;
  console.log(`\nRemaining data-translate-id markers: ${remainingMarkers} (should be 0)`);

  process.exit(0);
}
```

The test mode:
1. Extracts segments from IT file
2. Creates mock translations (uppercase each segment)
3. Reassembles and shows result
4. Verifies structure is preserved (same H1/H2/p/a counts)
5. Confirms data-translate-id markers are cleaned up
  </action>
  <verify>
```bash
node scripts/translate-batch.js --test-reassemble src/pages/permesso-studio.html 2>&1
```
Should show "REASSEMBLY TEST" with mock translations (uppercase), structure counts, and "Remaining data-translate-id markers: 0"
  </verify>
  <done>reassembleHtml function works, --test-reassemble shows properly reassembled HTML with mock translations and 0 remaining markers</done>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# 1. Segment extraction works
node scripts/translate-batch.js --test-extract src/pages/database.html 2>&1 | grep "segments"

# 2. Link transformation works
node scripts/translate-batch.js --test-links src/pages/permesso-studio.html 2>&1 | grep 'lang: en'

# 3. Path adjustments correct
node scripts/translate-batch.js --test-links src/pages/permesso-studio.html 2>&1 | grep "../../styles"

# 4. Reassembly works
node scripts/translate-batch.js --test-reassemble src/pages/chi-siamo.html 2>&1 | grep "Title:"

# 5. Markers cleaned up
node scripts/translate-batch.js --test-reassemble src/pages/database.html 2>&1 | grep "markers: 0"
```
</verification>

<success_criteria>
- [ ] extractSegments extracts 20+ segments from a typical permit page
- [ ] Title and meta description extracted separately
- [ ] --test-extract shows readable segment previews
- [ ] transformLinks sets lang="en" on html element
- [ ] Asset paths adjusted (../styles -> ../../styles)
- [ ] --test-links shows BEFORE/AFTER comparison
- [ ] reassembleHtml produces valid HTML with translated content
- [ ] Glossary post-processing function implemented
- [ ] --test-reassemble shows structure preserved and markers cleaned
- [ ] All test modes work: --test-extract, --test-links, --test-reassemble
</success_criteria>

<output>
After completion, create `.planning/phases/20-batch-translation-pipeline/20-02-SUMMARY.md`
</output>
