---
phase: 20-batch-translation-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - scripts/translate-batch.js
autonomous: true

must_haves:
  truths:
    - "HTML text segments can be extracted without losing structure"
    - "Internal links are transformed to /en/ paths"
    - "lang attribute is set to 'en' in output"
    - "Translated segments can be reassembled into valid HTML"
  artifacts:
    - path: "scripts/translate-batch.js"
      provides: "HTML extraction and reassembly functions"
      contains: "extractSegments"
    - path: "scripts/translate-batch.js"
      provides: "Link transformation function"
      contains: "transformLinks"
  key_links:
    - from: "scripts/translate-batch.js"
      to: "cheerio"
      via: "require/import"
      pattern: "cheerio"
    - from: "extractSegments"
      to: "reassembleHtml"
      via: "segment ID matching"
      pattern: "segment\\.id"
---

<objective>
Implement HTML segmentation and link transformation for structure-preserving translation.

Purpose: AI translation works best on clean text segments. This plan extracts translatable text, preserves HTML structure, and handles link path updates - the core transformation pipeline.

Output: Functions for extracting text segments, transforming links, and reassembling translated content back into valid HTML.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-batch-translation-pipeline/20-RESEARCH.md
@.planning/phases/20-batch-translation-pipeline/20-01-SUMMARY.md

# Reference for page structure
@en/src/pages/permesso-studio.html (POC translated page)
@src/pages/permesso-studio.html (IT source)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HTML segment extraction with cheerio</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add `extractSegments(html)` function using cheerio:

```javascript
const cheerio = require('cheerio');

/**
 * Extract translatable text segments from HTML
 * @param {string} html - Source HTML content
 * @returns {{ $: CheerioAPI, segments: Array, metadata: Object }}
 */
function extractSegments(html) {
  const $ = cheerio.load(html, { decodeEntities: false });
  const segments = [];
  let segmentId = 0;

  // Extract metadata first
  const metadata = {
    title: $('title').text(),
    description: $('meta[name="description"]').attr('content') || ''
  };

  // Mark metadata elements for later update
  $('title').attr('data-translate-id', 'title');
  $('meta[name="description"]').attr('data-translate-id', 'description');

  // Elements containing translatable text
  const textSelectors = [
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'p', 'li', 'td', 'th',
    'span:not(.no-translate)',
    'a:not([href^="http"]):not([href^="mailto"])',
    'button', 'label',
    '.alert', '.card-title', '.card-text',
    '.breadcrumb-item'
  ].join(', ');

  $(textSelectors).each((i, el) => {
    const $el = $(el);

    // Skip if inside script, style, or already processed parent
    if ($el.parents('script, style, noscript').length) return;
    if ($el.attr('data-translate-id')) return;

    // Skip empty or whitespace-only
    const text = $el.html();
    if (!text || !text.trim()) return;

    // Skip if translate="no" attribute
    if ($el.attr('translate') === 'no') return;

    // Skip children that will be processed separately
    if ($el.find(textSelectors).length > 0) {
      // Has child text elements - skip, they'll be processed
      return;
    }

    // Store segment with unique ID
    const id = segmentId++;
    $el.attr('data-translate-id', id.toString());

    segments.push({
      id,
      text: text.trim(),
      tagName: el.tagName.toLowerCase(),
      selector: generateSelector($el)
    });
  });

  return { $, segments, metadata };
}

/**
 * Generate a unique selector for an element
 */
function generateSelector($el) {
  const tag = $el[0].tagName.toLowerCase();
  const id = $el.attr('id');
  if (id) return `#${id}`;

  const classes = $el.attr('class');
  if (classes) {
    const firstClass = classes.split(' ')[0];
    return `${tag}.${firstClass}`;
  }

  return tag;
}
```

Key points:
- Use cheerio's `decodeEntities: false` to preserve HTML entities
- Mark elements with `data-translate-id` for later reassembly
- Skip nested text elements (process leaf nodes only)
- Preserve inner HTML (includes <strong>, <em>, <a> tags)
- Extract title and meta description separately
  </action>
  <verify>
Add test mode to script: `--test-extract path/to/file.html`
```bash
node scripts/translate-batch.js --test-extract src/pages/permesso-studio.html 2>&1 | head -30
```
Should show extracted segments with IDs
  </verify>
  <done>extractSegments function works, test shows 20+ segments extracted from a permit page</done>
</task>

<task type="auto">
  <name>Task 2: Implement link and path transformation</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add `transformLinks($)` function to update all internal links and asset paths:

```javascript
/**
 * Transform links and paths for EN version
 * EN pages are in /en/src/pages/ - one level deeper than IT
 * @param {CheerioAPI} $ - Cheerio instance
 */
function transformLinks($) {
  // Update lang attribute
  $('html').attr('lang', 'en');

  // Transform internal page links
  $('a[href]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');

    // Skip external links, anchors, mailto, tel
    if (!href) return;
    if (href.startsWith('http') || href.startsWith('#') ||
        href.startsWith('mailto:') || href.startsWith('tel:')) return;

    // Transform relative paths
    // IT: ../chi-siamo.html -> chi-siamo.html (same level in EN)
    // IT: chi-siamo.html -> chi-siamo.html (already relative)
    // Root: src/pages/x.html -> just use x.html for EN internal

    // For links within src/pages, keep filename only
    const filename = path.basename(href);
    if (href.includes('.html') && !href.includes('..')) {
      $el.attr('href', filename);
    }
  });

  // Transform asset paths (CSS, JS, images)
  // EN pages are in /en/src/pages/ - need to go up one more level
  // IT: ../styles/main.css
  // EN: ../../styles/main.css

  $('link[href^="../styles"]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');
    // ../styles -> ../../styles
    $el.attr('href', href.replace('../styles', '../../styles'));
  });

  $('script[src^="../scripts"]').each((i, el) => {
    const $el = $(el);
    const src = $el.attr('src');
    $el.attr('src', src.replace('../scripts', '../../scripts'));
  });

  // Images - adjust path depth
  $('img[src]').each((i, el) => {
    const $el = $(el);
    const src = $el.attr('src');
    if (src && src.startsWith('../')) {
      // Add one more level up
      $el.attr('src', '../' + src);
    }
  });

  // Logo specifically - from ../../../images to ../../../../images
  $('img[src*="images/logo"]').each((i, el) => {
    const $el = $(el);
    const src = $el.attr('src');
    if (src.includes('../../../images')) {
      $el.attr('src', src.replace('../../../images', '../../../../images'));
    }
  });

  // Favicon links
  $('link[href*="images/logo"]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');
    if (href.includes('../../../images')) {
      $el.attr('href', href.replace('../../../images', '../../../../images'));
    }
  });

  // Home link (logo)
  $('a[href="../../index.html"]').attr('href', '../../../en/index.html');
  $('a.logo[href]').each((i, el) => {
    const $el = $(el);
    const href = $el.attr('href');
    if (href && !href.includes('/en/')) {
      // Point to EN homepage
      $el.attr('href', '../../../en/index.html');
    }
  });
}
```

Important path mappings:
- IT `src/pages/x.html` -> EN `en/src/pages/x.html`
- Styles: `../styles/` -> `../../styles/`
- Images: `../../../images/` -> `../../../../images/`
- Home: `../../index.html` -> `../../../en/index.html`
  </action>
  <verify>
Add test mode: `--test-links path/to/file.html`
```bash
node scripts/translate-batch.js --test-links src/pages/permesso-studio.html 2>&1 | grep -E "(lang=|href=|src=)" | head -20
```
Should show lang="en" and adjusted paths
  </verify>
  <done>transformLinks function works, test shows lang="en" and correct ../../ path adjustments</done>
</task>

<task type="auto">
  <name>Task 3: Implement HTML reassembly from translated segments</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add `reassembleHtml($, translatedSegments, translatedMeta)` function:

```javascript
/**
 * Reassemble HTML with translated content
 * @param {CheerioAPI} $ - Cheerio instance with data-translate-id markers
 * @param {Array} translatedSegments - [{ id, text }] from Claude
 * @param {{ title: string, description: string }} translatedMeta
 * @returns {string} Complete translated HTML
 */
function reassembleHtml($, translatedSegments, translatedMeta) {
  // Create lookup map for fast access
  const translations = new Map(
    translatedSegments.map(s => [s.id.toString(), s.text])
  );

  // Update title
  if (translatedMeta.title) {
    $('title').text(translatedMeta.title);
  }

  // Update meta description
  if (translatedMeta.description) {
    $('meta[name="description"]').attr('content', translatedMeta.description);
  }

  // Update all marked elements
  $('[data-translate-id]').each((i, el) => {
    const $el = $(el);
    const id = $el.attr('data-translate-id');

    // Skip title and description (handled above)
    if (id === 'title' || id === 'description') return;

    const translated = translations.get(id);
    if (translated) {
      // Use html() to preserve any inner HTML formatting
      $el.html(translated);
    }

    // Remove the marker attribute
    $el.removeAttr('data-translate-id');
  });

  // Clean up any remaining markers
  $('[data-translate-id]').removeAttr('data-translate-id');

  return $.html();
}

/**
 * Apply glossary post-processing to translated text
 * Ensures consistent terminology even if AI varied
 */
function applyGlossaryPostProcess(html) {
  const glossary = require('./translation-glossary.json');
  let result = html;

  // Apply UI strings exactly (case-sensitive)
  for (const [it, en] of Object.entries(glossary.uiStrings)) {
    // Only replace if Italian string is found (shouldn't be, but safety check)
    result = result.split(it).join(en);
  }

  // For terms, do case-insensitive check for Italian -> ensure English
  // This catches any terms the AI might have missed
  for (const [it, en] of Object.entries(glossary.terms)) {
    const regex = new RegExp(`\\b${escapeRegex(it)}\\b`, 'gi');
    // Replace Italian term with English equivalent
    result = result.replace(regex, en);
  }

  return result;
}

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```

Add test mode: `--test-reassemble` that:
1. Extracts segments from IT file
2. Creates mock translations (uppercase each segment)
3. Reassembles and shows result
  </action>
  <verify>
```bash
node scripts/translate-batch.js --test-reassemble src/pages/permesso-studio.html 2>&1 | head -50
```
Should show HTML with uppercased text content (mock translation)
  </verify>
  <done>reassembleHtml function works, test shows properly reassembled HTML with mock translations</done>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# 1. Segment extraction works
node scripts/translate-batch.js --test-extract src/pages/database.html | grep "segments:" | head -1

# 2. Link transformation works
node scripts/translate-batch.js --test-links src/pages/permesso-studio.html | grep 'lang="en"'

# 3. Path adjustments correct
node scripts/translate-batch.js --test-links src/pages/permesso-studio.html | grep -c "../../styles"

# 4. Reassembly works
node scripts/translate-batch.js --test-reassemble src/pages/chi-siamo.html | grep "<title>" | head -1

# 5. Full pipeline test (extract -> mock translate -> reassemble)
node scripts/translate-batch.js --test-full src/pages/database.html 2>&1 | tail -20
```
</verification>

<success_criteria>
- [ ] extractSegments extracts 20+ segments from a typical permit page
- [ ] Title and meta description extracted separately
- [ ] transformLinks sets lang="en" on html element
- [ ] Asset paths adjusted (../styles -> ../../styles)
- [ ] Internal links preserved correctly
- [ ] reassembleHtml produces valid HTML with translated content
- [ ] Glossary post-processing function implemented
- [ ] Test modes work: --test-extract, --test-links, --test-reassemble
</success_criteria>

<output>
After completion, create `.planning/phases/20-batch-translation-pipeline/20-02-SUMMARY.md`
</output>
