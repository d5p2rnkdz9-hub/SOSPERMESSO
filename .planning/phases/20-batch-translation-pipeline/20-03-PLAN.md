---
phase: 20-batch-translation-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["20-01", "20-02"]
files_modified:
  - scripts/translate-batch.js
  - en/index.html
  - en/src/pages/*.html
autonomous: false

must_haves:
  truths:
    - "Script provides translateAll() function for batch processing"
    - "Script provides translateIndexHtml() function for root homepage"
    - "Script includes progress bar and batch status reporting"
    - "Script handles Anthropic Batch API submission and result retrieval"
  artifacts:
    - path: "scripts/translate-batch.js"
      provides: "Complete translation script with Batch API"
      contains: "messages.batches.create"
    - path: "scripts/translate-batch.js"
      provides: "Index.html translation function"
      contains: "translateIndexHtml"
    - path: "scripts/translation-manifest.json"
      provides: "Manifest structure for tracking"
      contains: "totalTranslated"
  key_links:
    - from: "scripts/translate-batch.js"
      to: "Anthropic API"
      via: "@anthropic-ai/sdk"
      pattern: "anthropic.messages.batches"
    - from: "scripts/translate-batch.js"
      to: "scripts/verify-translation.js"
      via: "exec or require"
      pattern: "verify"
---

<objective>
Implement Anthropic Batch API integration and execute full translation of all 208 pages.

Purpose: This is the core translation execution - connecting to Claude's Batch API, processing all pages in chunks, handling results, and producing the complete EN site.

Output: All 208 pages translated to EN in /en/ directory, passing verification, with manifest updated.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-batch-translation-pipeline/20-RESEARCH.md
@.planning/phases/20-batch-translation-pipeline/20-01-SUMMARY.md
@.planning/phases/20-batch-translation-pipeline/20-02-SUMMARY.md

# Verification script to run after translation
@scripts/verify-translation.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Anthropic Batch API integration</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add Anthropic Batch API integration following the research patterns:

```javascript
const Anthropic = require('@anthropic-ai/sdk');
const pLimit = require('p-limit');
const cliProgress = require('cli-progress');

// Initialize client (uses ANTHROPIC_API_KEY env var)
const anthropic = new Anthropic();

const BATCH_SIZE = 50;  // Pages per batch
const MODEL = 'claude-sonnet-4-5-20250514';
const MAX_TOKENS = 8192;

/**
 * Create translation batch request
 */
function createBatchRequest(pages, systemPrompt) {
  return pages.map(page => ({
    custom_id: page.filename,
    params: {
      model: MODEL,
      max_tokens: MAX_TOKENS,
      system: systemPrompt,
      messages: [{
        role: 'user',
        content: JSON.stringify({
          filename: page.filename,
          title: page.metadata.title,
          description: page.metadata.description,
          segments: page.segments.map(s => ({
            id: s.id,
            text: s.text
          }))
        })
      }]
    }
  }));
}

/**
 * Submit batch and poll for completion
 */
async function processBatch(requests, batchNumber, totalBatches) {
  console.log(`\nSubmitting batch ${batchNumber}/${totalBatches} (${requests.length} pages)...`);

  const batch = await anthropic.messages.batches.create({ requests });
  console.log(`Batch ID: ${batch.id}`);

  // Poll for completion
  const pollInterval = 30000; // 30 seconds
  const maxWait = 60 * 60 * 1000; // 1 hour max
  const startTime = Date.now();

  while (true) {
    const status = await anthropic.messages.batches.retrieve(batch.id);

    if (status.processing_status === 'ended') {
      console.log(`Batch ${batchNumber} completed!`);
      return batch.id;
    }

    if (Date.now() - startTime > maxWait) {
      throw new Error(`Batch ${batch.id} timed out after 1 hour`);
    }

    const elapsed = Math.round((Date.now() - startTime) / 1000);
    process.stdout.write(`\rWaiting... ${elapsed}s (status: ${status.processing_status})`);
    await new Promise(r => setTimeout(r, pollInterval));
  }
}

/**
 * Retrieve and process batch results
 */
async function retrieveResults(batchId) {
  const results = [];

  for await (const result of await anthropic.messages.batches.results(batchId)) {
    if (result.result.type === 'succeeded') {
      try {
        const content = result.result.message.content[0].text;
        const parsed = JSON.parse(content);
        results.push({
          filename: result.custom_id,
          segments: parsed.segments || parsed,
          title: parsed.title,
          description: parsed.description,
          success: true
        });
      } catch (e) {
        results.push({
          filename: result.custom_id,
          error: `Parse error: ${e.message}`,
          success: false
        });
      }
    } else {
      results.push({
        filename: result.custom_id,
        error: result.result.error?.message || 'Unknown error',
        success: false
      });
    }
  }

  return results;
}
```

Key implementation notes:
- Use claude-sonnet-4-5 (latest, best quality/cost)
- 50 pages per batch (safe under limits)
- 30-second polling interval
- 1-hour timeout per batch
- Parse JSON response carefully with error handling
  </action>
  <verify>
Test with single file first:
```bash
# Set API key
export ANTHROPIC_API_KEY="your-key-here"

# Test single file translation
node scripts/translate-batch.js --file src/pages/chi-siamo.html --output-dir /tmp/test-en

# Check output
cat /tmp/test-en/chi-siamo.html | grep 'lang="en"'
```
  </verify>
  <done>Single file translation works, produces valid EN HTML with lang="en"</done>
</task>

<task type="auto">
  <name>Task 2: Implement full batch translation with progress reporting</name>
  <files>scripts/translate-batch.js</files>
  <action>
Add the main translation orchestration with progress visibility:

```javascript
/**
 * Main translation function
 */
async function translateAll(options = {}) {
  const { force = false, batchSize = BATCH_SIZE, dryRun = false } = options;

  // 1. Build system prompt
  console.log('Loading glossary and building prompt...');
  const systemPrompt = await buildSystemPrompt();

  // 2. Discover pages
  console.log('Discovering pages...');
  const allPages = await discoverPages();
  console.log(`Found ${allPages.length} pages`);

  // 3. Load manifest and filter
  const manifest = await loadManifest();
  const pagesToTranslate = force
    ? allPages
    : allPages.filter(p => needsTranslation(p, manifest));

  console.log(`${pagesToTranslate.length} pages need translation`);

  if (dryRun) {
    console.log('\nDry run - pages that would be translated:');
    pagesToTranslate.slice(0, 20).forEach(p => console.log(`  - ${p.filename}`));
    if (pagesToTranslate.length > 20) {
      console.log(`  ... and ${pagesToTranslate.length - 20} more`);
    }
    return;
  }

  if (pagesToTranslate.length === 0) {
    console.log('All pages up to date!');
    return;
  }

  // 4. Extract segments from all pages with progress bar
  console.log('\nExtracting segments...');
  const extractBar = new cliProgress.SingleBar({
    format: 'Extracting |{bar}| {percentage}% | {value}/{total} pages'
  }, cliProgress.Presets.shades_classic);

  extractBar.start(pagesToTranslate.length, 0);

  const preparedPages = [];
  for (const page of pagesToTranslate) {
    const html = await fs.readFile(page.filepath, 'utf-8');
    const { $, segments, metadata } = extractSegments(html);
    preparedPages.push({
      ...page,
      $,
      segments,
      metadata,
      html
    });
    extractBar.increment();
  }
  extractBar.stop();

  // 5. Process in batches with progress
  const batches = [];
  for (let i = 0; i < preparedPages.length; i += batchSize) {
    batches.push(preparedPages.slice(i, i + batchSize));
  }

  console.log(`\n========================================`);
  console.log(`  BATCH TRANSLATION PROGRESS`);
  console.log(`========================================`);
  console.log(`Total pages: ${preparedPages.length}`);
  console.log(`Batch size: ${batchSize}`);
  console.log(`Total batches: ${batches.length}`);
  console.log(`Estimated time: ${batches.length * 5}-${batches.length * 15} minutes`);
  console.log(`========================================\n`);

  let successCount = 0;
  let errorCount = 0;
  const batchStartTime = Date.now();

  for (let i = 0; i < batches.length; i++) {
    const batch = batches[i];
    const requests = createBatchRequest(batch, systemPrompt);

    // Progress header for each batch
    const elapsed = Math.round((Date.now() - batchStartTime) / 60000);
    console.log(`\n[Batch ${i + 1}/${batches.length}] Elapsed: ${elapsed} min | Success: ${successCount} | Errors: ${errorCount}`);

    try {
      const batchId = await processBatch(requests, i + 1, batches.length);
      const results = await retrieveResults(batchId);

      // Write translated files with progress
      const writeBar = new cliProgress.SingleBar({
        format: 'Writing  |{bar}| {percentage}% | {value}/{total} pages'
      }, cliProgress.Presets.shades_classic);
      writeBar.start(results.length, 0);

      for (const result of results) {
        const page = batch.find(p => p.filename === result.filename);
        if (!page) continue;

        if (result.success) {
          await writeTranslatedPage(page, result, manifest);
          successCount++;
        } else {
          console.error(`\nError translating ${result.filename}: ${result.error}`);
          errorCount++;
        }
        writeBar.increment();
      }
      writeBar.stop();

      // Save manifest after each batch
      await saveManifest(manifest);
      console.log(`Manifest saved (${successCount} pages total)`);

    } catch (e) {
      console.error(`\nBatch ${i + 1} failed: ${e.message}`);
      errorCount += batch.length;
    }
  }

  // 6. Summary
  const totalTime = Math.round((Date.now() - batchStartTime) / 60000);
  console.log('\n========================================');
  console.log('  TRANSLATION COMPLETE');
  console.log('========================================');
  console.log(`Total time: ${totalTime} minutes`);
  console.log(`Successful: ${successCount}`);
  console.log(`Errors: ${errorCount}`);
  console.log(`Manifest updated: scripts/translation-manifest.json`);

  // 7. Run verification
  console.log('\nRunning verification...');
  const { execSync } = require('child_process');
  try {
    execSync('node scripts/verify-translation.js', { stdio: 'inherit' });
  } catch (e) {
    console.log('Verification found issues - review output above');
  }
}

/**
 * Write translated page to EN directory
 */
async function writeTranslatedPage(page, result, manifest) {
  // Re-extract segments to get fresh $ with data-translate-id markers
  // This ensures the markers exist for reassembleHtml to find
  const { $ } = extractSegments(page.html);

  // Reassemble with translations using the $ that has markers
  const translatedHtml = reassembleHtml(
    $,
    result.segments,
    { title: result.title, description: result.description }
  );

  // Transform links
  const $translated = cheerio.load(translatedHtml, { decodeEntities: false });
  transformLinks($translated);

  // Apply glossary post-processing
  let finalHtml = $translated.html();
  finalHtml = applyGlossaryPostProcess(finalHtml);

  // Write to EN directory
  const outputPath = path.join(__dirname, '../en/src/pages', page.filename);
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, finalHtml, 'utf-8');

  // Update manifest
  manifest.pages[page.filename] = {
    translated: new Date().toISOString(),
    sourceMtime: page.mtime
  };
  manifest.meta.totalTranslated = Object.keys(manifest.pages).length;
  manifest.meta.lastRun = new Date().toISOString();
}
```
  </action>
  <verify>
```bash
# Translate small batch first (5 pages)
node scripts/translate-batch.js --batch-size 5 --max-pages 5

# Check results
ls -la en/src/pages/ | head -10
node scripts/verify-translation.js 2>&1 | tail -20
```
  </verify>
  <done>Batch translation works for small batch, produces valid EN pages that pass verification</done>
</task>

<task type="auto">
  <name>Task 3: Implement index.html translation and execute full batch</name>
  <files>scripts/translate-batch.js, en/index.html, en/src/pages/*.html, scripts/translation-manifest.json</files>
  <action>
Add dedicated index.html translation function. The root index.html has different path structure than src/pages/ files:

```javascript
/**
 * Translate root index.html separately
 *
 * Root index.html differs from src/pages/*.html:
 * - Input: ./index.html (not src/pages/)
 * - Output: ./en/index.html (not en/src/pages/)
 * - Link paths are different (src/pages/x.html not ../x.html)
 */
async function translateIndexHtml(systemPrompt) {
  console.log('\nTranslating root index.html...');

  const inputPath = path.join(__dirname, '../index.html');
  const outputPath = path.join(__dirname, '../en/index.html');

  // Read source
  const html = await fs.readFile(inputPath, 'utf-8');

  // Extract segments
  const { $, segments, metadata } = extractSegments(html);

  console.log(`  Extracted ${segments.length} segments from index.html`);

  // Create single-page batch request
  const request = {
    custom_id: 'index.html',
    params: {
      model: MODEL,
      max_tokens: MAX_TOKENS,
      system: systemPrompt,
      messages: [{
        role: 'user',
        content: JSON.stringify({
          filename: 'index.html',
          title: metadata.title,
          description: metadata.description,
          segments: segments.map(s => ({ id: s.id, text: s.text }))
        })
      }]
    }
  };

  // Use single message for index (not batch, faster for one file)
  const response = await anthropic.messages.create({
    model: MODEL,
    max_tokens: MAX_TOKENS,
    system: systemPrompt,
    messages: request.params.messages
  });

  const parsed = JSON.parse(response.content[0].text);

  // Reassemble with translations
  const $source = cheerio.load(html, { decodeEntities: false });
  const translatedHtml = reassembleHtml(
    $source,
    parsed.segments || parsed,
    { title: parsed.title, description: parsed.description }
  );

  // Transform links - index.html specific paths
  const $translated = cheerio.load(translatedHtml, { decodeEntities: false });

  // Set language
  $translated('html').attr('lang', 'en');

  // Root index.html link transformations:
  // IT: src/pages/database.html -> en/src/pages/database.html
  // IT: src/pages/chi-siamo.html -> en/src/pages/chi-siamo.html
  $translated('a[href^="src/pages/"]').each((i, el) => {
    const $el = $translated(el);
    const href = $el.attr('href');
    // src/pages/x.html -> en/src/pages/x.html
    $el.attr('href', 'en/' + href);
  });

  // Navigation dropdowns link to en/ versions
  $translated('a[href*=".html"]').each((i, el) => {
    const $el = $translated(el);
    const href = $el.attr('href');
    // Skip external and already-transformed links
    if (!href || href.startsWith('http') || href.startsWith('en/')) return;
    if (href.includes('src/pages/')) {
      $el.attr('href', 'en/' + href);
    }
  });

  // CSS/JS paths stay same (en/ is at same level as src/)
  // No transformation needed for ../styles or ../scripts

  // Apply glossary post-processing
  let finalHtml = $translated.html();
  finalHtml = applyGlossaryPostProcess(finalHtml);

  // Write to EN directory
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, finalHtml, 'utf-8');

  console.log(`  Written: ${outputPath}`);
  return true;
}
```

Update the main translateAll() function to call translateIndexHtml() at the end:

```javascript
async function translateAll(options = {}) {
  // ... existing batch translation code ...

  // After all src/pages done, translate index.html
  console.log('\n----------------------------------------');
  console.log('Translating homepage...');
  await translateIndexHtml(systemPrompt);

  // Update manifest for index
  manifest.pages['index.html'] = {
    translated: new Date().toISOString(),
    sourceMtime: fs.statSync(path.join(__dirname, '../index.html')).mtimeMs
  };
  manifest.meta.totalTranslated = Object.keys(manifest.pages).length;
  await saveManifest(manifest);

  // ... verification code ...
}
```

Execute complete translation:

```bash
# Run full translation (will take 1-2 hours due to batch processing)
npm run translate:en

# Or with explicit batch size
npm run translate:en -- --batch-size 50
```

After completion:
1. Run verification script
2. Fix any issues reported
3. Commit translated pages

Expected output structure:
```
en/
├── index.html                    # Translated homepage
└── src/
    └── pages/
        ├── database.html         # 1 of 208
        ├── chi-siamo.html
        ├── documenti-questura.html
        ├── permesso-*.html       # ~67 permit pages
        ├── documenti-*.html      # ~100 document pages
        └── ...                   # All 208 pages
```
  </action>
  <verify>
```bash
# Count translated pages
find en/src/pages -name "*.html" | wc -l
# Should be 208

# Check index.html specifically
test -f en/index.html && echo "index.html exists" || echo "MISSING"
grep 'lang="en"' en/index.html

# Run verification
node scripts/verify-translation.js
# Should pass with no errors (warnings OK)

# Check manifest
cat scripts/translation-manifest.json | grep totalTranslated
# Should show 209 (208 pages + index.html)

# Spot check a few pages
grep 'lang="en"' en/src/pages/database.html
grep 'residence permit' en/src/pages/permesso-studio.html
```
  </verify>
  <done>All 208 pages + index.html translated, verification passes, manifest shows 209 pages</done>
</task>

</tasks>

<checkpoint type="human-verify" gate="blocking">
<what-built>Complete EN translation of all 208 pages + homepage using AI batch translation</what-built>
<how-to-verify>
1. Open `en/src/pages/database.html` in browser
   - Verify page displays correctly
   - Check all permit names are in English
   - Click a few links - should go to EN pages

2. Open `en/src/pages/permesso-studio.html` in browser
   - Verify content is in English
   - Check that "permesso di soggiorno" appears as "residence permit"
   - Verify navigation links work

3. Run verification script:
```bash
node scripts/verify-translation.js
```
   - Should show mostly green checks
   - Warnings are OK, errors need fixing

4. Check a random document page:
   - `en/src/pages/documenti-studio-primo.html`
   - Checklist should be in English
   - "Documenti necessari" should be "Required documents"

5. Verify homepage:
   - Open `en/index.html`
   - All sections should be in English
   - Links should point to en/src/pages/ paths
</how-to-verify>
<resume-signal>Type "approved" if translations look good, or describe specific issues to fix</resume-signal>
</checkpoint>

<verification>
Run these commands to verify plan completion:

```bash
# 1. All pages translated
find en/src/pages -name "*.html" | wc -l
# Expected: 208

# 2. Homepage translated
test -f en/index.html && grep 'lang="en"' en/index.html

# 3. Verification passes
node scripts/verify-translation.js 2>&1 | grep -E "^(Total|Passed|Failed)"

# 4. Manifest updated
cat scripts/translation-manifest.json | grep -E "(totalTranslated|lastRun)"

# 5. Lang attribute correct
grep -l 'lang="it"' en/src/pages/*.html | wc -l
# Expected: 0 (no Italian lang)

grep -l 'lang="en"' en/src/pages/*.html | wc -l
# Expected: 208

# 6. Key terms translated
grep -c "residence permit" en/src/pages/database.html
# Expected: > 0
```
</verification>

<success_criteria>
- [ ] Anthropic Batch API integration working
- [ ] Single file translation test passes
- [ ] All 208 pages translated to EN
- [ ] All pages have lang="en" attribute
- [ ] Verification script passes with no errors
- [ ] Internal links point to EN pages
- [ ] Manifest tracks all 209 translations (208 + index)
- [ ] Homepage (en/index.html) translated with correct paths
- [ ] User approves quality spot-check
</success_criteria>

<output>
After completion, create `.planning/phases/20-batch-translation-pipeline/20-03-SUMMARY.md`
</output>
