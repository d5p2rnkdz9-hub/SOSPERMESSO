---
phase: 47-notion-cache
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/notion-cache.js
  - _data/permits.js
  - _data/documents.js
  - package.json
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Second build with no Notion changes shows 0 misses and all cache hits in permits.js"
    - "Build log prints cache hit/miss counts for permits (e.g. 'Cache: 43 hits, 0 misses')"
    - "npm run cache:clear deletes .notion-cache/ directory"
    - ".notion-cache/ directory is gitignored and never committed"
  artifacts:
    - path: "scripts/notion-cache.js"
      provides: "Shared cache module for Notion API responses"
      exports: ["loadPagesIndex", "savePagesIndex", "getBlocks", "setBlocks", "clearCache"]
    - path: "_data/permits.js"
      provides: "Cache-aware permit data fetching"
      contains: "require('../scripts/notion-cache')"
    - path: "package.json"
      provides: "cache:clear npm script"
      contains: "cache:clear"
    - path: ".gitignore"
      provides: "Cache directory exclusion"
      contains: ".notion-cache/"
  key_links:
    - from: "_data/permits.js"
      to: "scripts/notion-cache.js"
      via: "require('../scripts/notion-cache')"
      pattern: "require.*notion-cache"
    - from: "_data/permits.js"
      to: ".notion-cache/blocks/"
      via: "cache.getBlocks() / cache.setBlocks()"
      pattern: "cache\\.(get|set)Blocks"
    - from: "package.json"
      to: "scripts/notion-cache.js"
      via: "cache:clear script"
      pattern: "cache:clear.*notion-cache"
---

<objective>
Implement a local file-based cache for Notion API responses so that 11ty builds skip block fetches for unchanged Notion pages.

Purpose: The current build re-fetches all 43 permit block trees from Notion on every build (~15s of API wait time). This cache reduces repeat builds to near-zero API time by comparing `last_edited_time` from Notion's search response against cached timestamps.

Output: A working `scripts/notion-cache.js` module integrated into `_data/permits.js`, with `npm run cache:clear` and `.gitignore` entry.
</objective>

<execution_context>
@/Users/albertopasquero/.claude/get-shit-done/workflows/execute-plan.md
@/Users/albertopasquero/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/47-notion-cache/47-RESEARCH.md

Key files to read before implementing:
@scripts/translation-memory.js — follow this exact pattern for cache module (CommonJS, fs/promises, graceful miss)
@_data/permits.js — main file to modify (line 83 already extracts last_edited_time)
@_data/documents.js — minor update: cache search result for consistency
@package.json — add cache:clear script
@.gitignore — add .notion-cache/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notion-cache.js module and wire into permits.js</name>
  <files>scripts/notion-cache.js, _data/permits.js, _data/documents.js, package.json, .gitignore</files>
  <action>
**1. Create `scripts/notion-cache.js`** (new file, CommonJS module)

Follow the pattern from `scripts/translation-memory.js` exactly. The module provides:

```
const CACHE_DIR = path.join(process.cwd(), '.notion-cache');
const PAGES_INDEX_PATH = path.join(CACHE_DIR, 'pages.json');
const BLOCKS_DIR = path.join(CACHE_DIR, 'blocks');
```

Exports:
- `loadPagesIndex()` — reads `pages.json`, returns `{}` on miss (graceful)
- `savePagesIndex(index)` — writes `pages.json` (creates dirs with `recursive: true`)
- `getBlocks(pageId)` — reads `blocks/{pageId}.json`, returns `null` on miss
- `setBlocks(pageId, blocks)` — writes `blocks/{pageId}.json`
- `clearCache()` — deletes `.notion-cache/` recursively with `fs.rm(CACHE_DIR, { recursive: true, force: true })`, logs result
- `CACHE_DIR` — exported for external use

Use `fs/promises` (not sync). Use `require('fs/promises')` and `require('path')` only — no new dependencies.

**2. Modify `_data/permits.js`** — integrate cache into the block fetching loop

At the top, add: `const cache = require('../scripts/notion-cache');`

In the `module.exports` function, AFTER `fetchPermitData(notion)` returns and BEFORE the per-permit loop:
- Load pages index: `const pagesIndex = await cache.loadPagesIndex();`
- Initialize counters: `let cacheHits = 0, cacheMisses = 0;`

Inside the per-permit loop (currently lines 493-543), replace the unconditional `fetchPageBlocks` call with cache-aware logic:

```js
// Check if page changed since last cache
const cachedEntry = pagesIndex[permit.id];
const pageChanged = !cachedEntry || cachedEntry.last_edited_time !== permit.last_edited_time;

let blocks;
if (!pageChanged) {
  blocks = await cache.getBlocks(permit.id);
}

if (blocks) {
  cacheHits++;
} else {
  cacheMisses++;
  // Rate limiting: 350ms delay between Notion API requests
  await delay(350);
  blocks = await fetchPageBlocks(notion, permit.id);
  // Save to cache
  await cache.setBlocks(permit.id, blocks);
  pagesIndex[permit.id] = {
    last_edited_time: permit.last_edited_time,
    fetchedAt: new Date().toISOString()
  };
}
```

IMPORTANT: Compare `last_edited_time` with strict string equality (`!==`), NOT as Date objects. If `getBlocks()` returns `null` despite the index saying cached, treat as miss (re-fetch).

After the loop, save the updated index and log stats:
```js
await cache.savePagesIndex(pagesIndex);
console.log(`[permits.js] Cache: ${cacheHits} hits, ${cacheMisses} misses`);
```

Remove the existing `await delay(350)` that's unconditional — it should only run on cache misses (before the Notion API call).

**3. Modify `_data/documents.js`** — minimal cache logging for consistency

documents.js does NOT fetch blocks — only a search. The caching benefit is minimal. Add a single log line after the search completes to note this for Phase 48 compatibility:
```js
console.log(`[documents.js] Search fetched ${allPages.length} pages (no block cache — search only)`);
```

This keeps documents.js simple. Do NOT add block caching to documents.js — it doesn't fetch blocks.

**4. Modify `package.json`** — add `cache:clear` script

Add to `"scripts"`:
```json
"cache:clear": "node -e \"require('./scripts/notion-cache').clearCache()\""
```

Follow the same inline pattern as the existing `tm:stats` script.

**5. Modify `.gitignore`** — add `.notion-cache/`

Add a blank line + comment + entry:
```
# Notion API response cache
.notion-cache/
```
  </action>
  <verify>
1. Run `node -e "const c = require('./scripts/notion-cache'); console.log(Object.keys(c));"` from project root — should print the 6 exports
2. Run `npm run cache:clear` — should print "[notion-cache] Cache cleared" without error
3. Run `npm run build` — should complete successfully, showing cache miss counts (all misses on first run)
4. Run `npm run build` again — should show all cache hits, 0 misses
5. Run `git status` — `.notion-cache/` should NOT appear in untracked files (gitignored)
  </verify>
  <done>
- `scripts/notion-cache.js` exists with 6 exports following the translation-memory.js pattern
- `_data/permits.js` uses cache: skips block fetch when `last_edited_time` matches, logs hit/miss counts
- `package.json` has `cache:clear` script
- `.gitignore` includes `.notion-cache/`
- Build succeeds on first run (all misses), second run shows all hits
  </done>
</task>

</tasks>

<verification>
1. First build: all cache misses (43 misses, 0 hits) — `.notion-cache/blocks/` contains 43 JSON files
2. Second build (no Notion changes): all cache hits (0 misses, 43 hits) — no Notion block API calls
3. `npm run cache:clear` deletes `.notion-cache/` entirely
4. Third build (after clear): all misses again (cache was cleared)
5. `.notion-cache/` does NOT appear in `git status`
6. Build output still produces correct HTML pages (no content regression)
</verification>

<success_criteria>
- Running `npm run build` twice consecutively shows 43 hits / 0 misses on the second run
- `npm run cache:clear` works without errors
- `.notion-cache/` is gitignored
- Build log clearly shows cache hit/miss statistics
</success_criteria>

<output>
After completion, create `.planning/phases/47-notion-cache/47-01-SUMMARY.md`
</output>
