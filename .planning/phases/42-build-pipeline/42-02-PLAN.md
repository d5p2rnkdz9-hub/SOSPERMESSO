---
phase: 42-build-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - netlify/functions/notion-webhook.mjs
  - package.json
autonomous: true

must_haves:
  truths:
    - "Notion content changes trigger a Netlify rebuild automatically"
    - "Rapid successive edits in Notion do not trigger multiple builds (30-min debounce)"
    - "Manual rebuild trigger still works (direct POST to build hook URL)"
    - "Webhook signature verification still works correctly"
  artifacts:
    - path: "netlify/functions/notion-webhook.mjs"
      provides: "Webhook handler with 30-minute debounce via Netlify Blobs"
      contains: "getStore"
    - path: "package.json"
      provides: "@netlify/blobs dependency"
      contains: "@netlify/blobs"
  key_links:
    - from: "netlify/functions/notion-webhook.mjs"
      to: "Netlify Blobs"
      via: "getStore('webhook-state')"
      pattern: "getStore.*webhook-state"
    - from: "netlify/functions/notion-webhook.mjs"
      to: "Netlify Build Hooks"
      via: "fetch(NETLIFY_BUILD_HOOK_URL)"
      pattern: "fetch.*NETLIFY_BUILD_HOOK_URL"
---

<objective>
Add 30-minute debounce to the Notion webhook handler so batch edits in Notion trigger only one rebuild instead of many.

Purpose: The user typically makes multiple edits in a session. Without debounce, each edit triggers a separate Netlify build, wasting build minutes. A 30-minute window ensures builds happen at most once per editing session.

Output: Updated notion-webhook.mjs with Netlify Blobs-based debounce, @netlify/blobs dependency installed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/42-build-pipeline/42-RESEARCH.md

# Key source files
@netlify/functions/notion-webhook.mjs
@package.json
@netlify.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @netlify/blobs and extend webhook with debounce</name>
  <files>netlify/functions/notion-webhook.mjs, package.json</files>
  <action>
**Step A: Install @netlify/blobs**

Run `npm install @netlify/blobs` to add the Netlify Blobs SDK as a dependency. This provides persistent key-value storage that works across serverless function invocations (zero-config on Netlify).

**Step B: Extend notion-webhook.mjs with 30-minute debounce**

Modify the existing `notion-webhook.mjs` to add debounce logic using Netlify Blobs. The existing code structure (signature verification, challenge handling, event routing) MUST be preserved. Add debounce ONLY in the content update event handler.

Changes to make:
1. Add `import { getStore } from '@netlify/blobs';` at the top (after existing crypto import)
2. Define `const DEBOUNCE_WINDOW_MS = 30 * 60 * 1000;` as a constant
3. Inside the `if (eventType === 'page.content_updated' || eventType === 'data_source.schema_updated')` block, BEFORE triggering the build:
   - Get the `webhook-state` store: `const store = getStore('webhook-state');`
   - Read last trigger timestamp: `const lastTriggerStr = await store.get('last-build-trigger');`
   - Parse it: `const lastTrigger = lastTriggerStr ? new Date(lastTriggerStr) : null;`
   - Check if within debounce window: `if (lastTrigger && (now - lastTrigger) < DEBOUNCE_WINDOW_MS)`
   - If debounced: return 200 with `{ message: 'Debounced', minutes_since_last: ... }` and log it
   - If NOT debounced: update timestamp FIRST (`await store.set('last-build-trigger', now.toISOString())`), THEN trigger build

4. Keep the existing build trigger logic (fetch to NETLIFY_BUILD_HOOK_URL) but add `trigger_title` in the POST body:
   ```javascript
   const buildResponse = await fetch(buildHookUrl, {
     method: 'POST',
     body: JSON.stringify({ trigger_title: 'Notion content updated' })
   });
   ```

5. Add logging for all debounce decisions:
   - `[notion-webhook] Debounced: Xmin since last trigger (< 30min)`
   - `[notion-webhook] Triggering build (30min window passed or first trigger)`

**DO NOT change:**
- The signature verification logic (timing-safe comparison)
- The url_verification challenge handler
- The method check (POST only)
- The error handling structure

The full updated handler should follow the code example in 42-RESEARCH.md (Architecture Patterns > Pattern 1), adapted to preserve the existing code structure.
  </action>
  <verify>
1. `grep "getStore" netlify/functions/notion-webhook.mjs` — shows Blobs import usage
2. `grep "DEBOUNCE_WINDOW_MS" netlify/functions/notion-webhook.mjs` — shows constant defined
3. `grep "@netlify/blobs" package.json` — shows dependency installed
4. `grep "timingSafeEqual" netlify/functions/notion-webhook.mjs` — shows signature verification preserved
5. `grep "url_verification" netlify/functions/notion-webhook.mjs` — shows challenge handler preserved
6. `node -e "require('@netlify/blobs')"` — module loads without error
  </verify>
  <done>notion-webhook.mjs extended with 30-minute debounce using Netlify Blobs. Signature verification and challenge handling preserved. @netlify/blobs dependency installed.</done>
</task>

</tasks>

<verification>
1. notion-webhook.mjs contains debounce logic with Netlify Blobs
2. Existing webhook features preserved (signature verification, challenge, event routing)
3. @netlify/blobs is in package.json dependencies
4. DEBOUNCE_WINDOW_MS set to 30 minutes (1800000ms)
5. Debounce checks timestamp before triggering build
6. Timestamp updated before build trigger (prevents race condition window)
</verification>

<success_criteria>
- Webhook handler includes 30-minute debounce window
- @netlify/blobs dependency installed
- Signature verification unchanged
- Build trigger includes descriptive trigger_title
- Debounce decisions are logged for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/42-build-pipeline/42-02-SUMMARY.md`
</output>
