---
phase: 40-permit-pages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - _data/permits.js
  - eleventy.config.mjs
autonomous: true

must_haves:
  truths:
    - "permits.js returns an array of permit objects with pre-parsed Q&A HTML when NOTION_API_KEY is set"
    - "permits.js returns empty array when NOTION_API_KEY is not set (graceful degradation)"
    - "Variant permits are detected and grouped — parent objects have isVariantParent:true and variants array"
    - "getSectionBorderColor filter is available in Liquid templates"
  artifacts:
    - path: "_data/permits.js"
      provides: "Async data file returning array of parsed permit objects"
      exports: ["module.exports (async function)"]
    - path: "eleventy.config.mjs"
      provides: "getSectionBorderColor filter registration"
      contains: "getSectionBorderColor"
  key_links:
    - from: "_data/permits.js"
      to: "scripts/notion-client.js"
      via: "require for fetchPermitData and fetchPageBlocks"
      pattern: "require.*notion-client"
    - from: "_data/permits.js"
      to: "scripts/build-permits.js"
      via: "imported Q&A parsing functions (extractPlainText, richTextToHtml, isQuestionBlock, blockToHtml, groupAndRenderBlocks, parseQASections)"
      pattern: "parseQASections|richTextToHtml"
    - from: "eleventy.config.mjs"
      to: "Liquid templates"
      via: "addFilter registration"
      pattern: "addFilter.*getSectionBorderColor"
---

<objective>
Create the 11ty data file that fetches permit data from Notion, parses Q&A content into HTML, detects variant groups, and returns a structured array. Also register the getSectionBorderColor filter needed by the permit template.

Purpose: This is the data backbone for Phase 40. The data file replaces the fetch+parse logic from scripts/build-permits.js. Once this exists, the Liquid template (Plan 02) can render permit pages.

Output: `_data/permits.js` data file + `getSectionBorderColor` filter in eleventy.config.mjs
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-document-pages/39-01-SUMMARY.md

Key source files to read and adapt from:
@scripts/build-permits.js — Q&A parsing functions to import (lines 83-370: extractPlainText, richTextToHtml, isQuestionBlock, blockToHtml, groupAndRenderBlocks, parseQASections, slugify, detectVariants, getEmojiForPermit)
@scripts/notion-client.js — fetchPermitData() and fetchPageBlocks() to reuse
@scripts/templates/helpers.js — escapeHtml and linkToDizionario (already imported by richTextToHtml in build-permits.js)
@scripts/templates/permesso.js — getSectionBorderColor function (lines 14-47) to register as filter
@_data/documents.js — Phase 39 pattern to follow for data file structure
@eleventy.config.mjs — Current config to add filter to
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create _data/permits.js data file</name>
  <files>_data/permits.js</files>
  <action>
Create `_data/permits.js` as a CommonJS async data file (matching _data/documents.js pattern).

The data file must:

1. **Import existing functions — do NOT rewrite them:**
   - From `scripts/notion-client.js`: `fetchPermitData`, `fetchPageBlocks`
   - From `scripts/build-permits.js`: `extractPlainText`, `richTextToHtml`, `isQuestionBlock`, `blockToHtml`, `groupAndRenderBlocks`, `parseQASections`

   IMPORTANT: build-permits.js does NOT currently export these functions. You must FIRST add exports at the bottom of build-permits.js:
   ```javascript
   // At the END of build-permits.js, ADD to the existing module or add:
   module.exports = { extractPlainText, richTextToHtml, isQuestionBlock, blockToHtml, groupAndRenderBlocks, parseQASections, slugify, detectVariants, getEmojiForPermit };
   ```
   BUT WAIT — build-permits.js has `build().catch(...)` at the bottom that runs on require. This means we CANNOT simply require it. Instead:

   **Best approach: Copy the 6 parsing functions + slugify + detectVariants + getEmojiForPermit into permits.js directly.** These functions are ~290 lines. This avoids modifying build-permits.js and avoids side-effect execution. The functions are: extractPlainText (lines 83-88), richTextToHtml (lines 96-132), isQuestionBlock (lines 143-168), blockToHtml (lines 176-249), groupAndRenderBlocks (lines 256-302), parseQASections (lines 309-370), slugify (lines 377-384), detectVariants (lines 392-435), getEmojiForPermit (lines 442-457).

   These functions import `escapeHtml` and `linkToDizionario` from helpers.js, so permits.js must also require those.

2. **Graceful degradation:** If NOTION_API_KEY is not set, log a warning and return empty array `[]`.

3. **Fetch permit pages from Notion:**
   - Use `fetchPermitData()` from notion-client.js to get all permit pages
   - This returns array of objects with: id, tipo, slug, primoDocuments, rinnovoDocuments, primoMethod, rinnovoMethod, docNotes, last_edited_time

4. **For each permit with a tipo:**
   - Fetch page blocks using `fetchPageBlocks(permit.id)` from notion-client.js
   - Parse Q&A sections using `parseQASections(blocks)`
   - Build permit object with: id, slug, tipo, emoji (from getEmojiForPermit), sections (array of {question, content, index}), isPlaceholder (true if no sections)
   - Add 350ms delay between permits for rate limiting
   - Log progress every 10 permits

5. **Detect variants:**
   - After processing all permits, call `detectVariants(permits)`
   - This returns `{ variantGroups, standalone }`
   - For each variantGroup with 2+ variants: create a synthetic parent object with `isVariantParent: true`, `baseName`, `slug` (from baseSlug), `tipo` (baseName), `emoji` (from getEmojiForPermit), and `variants` array
   - Mark each variant child with `isVariantChild: true`, `baseName`, `variantName`
   - Single-variant items go back to standalone

6. **Return flat array** combining: standalone permits + variant parents + variant children. This flat array is what the template will paginate over.

7. **Error handling:** Wrap entire function in try/catch. On error, log and return empty array.

The returned objects should have this shape:
```javascript
// Standard permit:
{ id, slug, tipo, emoji, sections: [{question, content, index}], isPlaceholder: bool }

// Variant parent (synthetic):
{ slug, tipo, emoji, isVariantParent: true, baseName, variants: [{slug, tipo, emoji, variantName}] }

// Variant child:
{ id, slug, tipo, emoji, sections: [...], isVariantChild: true, baseName, variantName, isPlaceholder: bool }
```
  </action>
  <verify>
Run: `node -e "require('./_data/permits.js')().then(d => console.log('Count:', d.length, 'Parents:', d.filter(p=>p.isVariantParent).length))"`
- Without NOTION_API_KEY: should print "Count: 0 Parents: 0" and a warning
- With NOTION_API_KEY set: should print count of permits and variant parents
Also verify: `npx @11ty/eleventy --dryrun` completes without errors
  </verify>
  <done>
_data/permits.js exists, exports async function, returns array of permit objects with pre-parsed Q&A HTML, handles graceful degradation, detects variants
  </done>
</task>

<task type="auto">
  <name>Task 2: Register getSectionBorderColor filter in eleventy.config.mjs</name>
  <files>eleventy.config.mjs</files>
  <action>
Add the `getSectionBorderColor` filter to eleventy.config.mjs.

Read the current eleventy.config.mjs first. Then add the filter after the existing filter registrations (after the parseDocNotes filter block).

The filter implementation should be copied from scripts/templates/permesso.js lines 14-47 (the getSectionBorderColor function). Register it as:

```javascript
/**
 * getSectionBorderColor - Return border color for permit Q&A section cards
 * Based on question keywords, with index-based fallback for variety
 * Usage: {{ section.index | getSectionBorderColor: section.question }}
 */
eleventyConfig.addFilter("getSectionBorderColor", function(index, question) {
  const q = (question || '').toLowerCase();

  // Match by keywords first
  if (q.includes("cos'è") || q.includes("che cos'è") || q.includes("che cosa")) return 'var(--accent-blue)';
  if (q.includes('requisiti') || q.includes('chi può') || q.includes('chi puo')) return 'var(--taxi-yellow)';
  if (q.includes('lavorare') || q.includes('lavoro') || q.includes('diritti')) return 'var(--lighthouse-red)';
  if (q.includes('conversione') || q.includes('convertire')) return 'var(--accent-teal)';
  if (q.includes('durata') || q.includes('quanto dura')) return 'var(--accent-blue)';
  if (q.includes('costi') || q.includes('quanto costa')) return 'var(--accent-orange)';

  // Fallback by index for variety
  const colors = [
    'var(--accent-blue)',
    'var(--taxi-yellow)',
    'var(--lighthouse-red)',
    'var(--accent-teal)',
    'var(--accent-purple)',
    'var(--accent-orange)'
  ];
  return colors[index % colors.length];
});
```

Place this after the `parseDocNotes` filter registration and before the passthrough copy section.
  </action>
  <verify>
Run: `npx @11ty/eleventy --dryrun` — should complete without errors.
Verify the filter exists: `grep -n "getSectionBorderColor" eleventy.config.mjs` should show the registration.
  </verify>
  <done>
getSectionBorderColor filter registered in eleventy.config.mjs, build runs without errors
  </done>
</task>

</tasks>

<verification>
1. `_data/permits.js` exists and is a valid CommonJS module
2. Without NOTION_API_KEY: `node -e "require('./_data/permits.js')().then(d => console.log(d.length))"` prints 0
3. `npx @11ty/eleventy --dryrun` completes without errors
4. `grep "getSectionBorderColor" eleventy.config.mjs` finds the filter
</verification>

<success_criteria>
- _data/permits.js fetches permit data + page blocks from Notion, parses Q&A to HTML, detects variants
- getSectionBorderColor filter registered and usable in Liquid templates
- Build pipeline runs without errors (dryrun passes)
- Graceful degradation works (empty array when no API key)
</success_criteria>

<output>
After completion, create `.planning/phases/40-permit-pages/40-01-SUMMARY.md`
</output>
